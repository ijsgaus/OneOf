<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
using System;
using Newtonsoft.Json;

namespace OneOf
{
<#	for (var i = 1; i < 16; i++)
	{
		var typeList = Enumerable.Range(0, i)
			.Aggregate(new StringBuilder(), (sb, k) => sb.Append(sb.Length == 0 ? "T0" : $", T{k}"), sb => sb.ToString());
#>
	[JsonConverter(typeof(OneOfBaseJsonConverter))]
	public abstract class OneOfBase<<#= typeList#>>	: IOneOf<<#= typeList#>>, IEquatable<OneOfBase<<#= typeList#>>>
	{
		protected OneOfBase(object value, int tag)
		{
			_value = value;
			_tag = tag;
		}

		private readonly object _value;
		private readonly int _tag;

		object IOneOf.Value => _value;
		int IOneOf.Tag => _tag;

<#
		for (var j = 0; j < i; j++)
		{
#>
		bool IOneOf<<#= typeList#>>.IsT<#= j #>  => _tag == <#= j #>;
		T<#= j #> IOneOf<<#= typeList#>>.AsT<#= j #> 
		{ 
			get 
			{ 
				if(_tag != <#= j #>) throw new InvalidOperationException($"Cannot return as {typeof(T<#= j #>)} as result, value is {_value?.GetType()}");  
				return (T<#= j #>) _value;
			}
		}

<#
		}
#>		
		public bool Equals(OneOfBase<<#= typeList #>> oneOf)
		{
			return oneOf != null && oneOf._tag == _tag && Equals(oneOf._value, _value);
		}

		public override bool Equals(object obj)
	    {
			if (ReferenceEquals(null, obj)) return false;
			if (ReferenceEquals(this, obj)) return true;
			var oob = obj as OneOfBase<<#= typeList#>>;
	        return oob != null && Equals(oob);
	    }

	    public override int GetHashCode()
	    {
	        unchecked
            {
                return ((_value?.GetHashCode() ?? 0)*397) ^ _tag;
            }
	    }
		
	}

<# }#>
}